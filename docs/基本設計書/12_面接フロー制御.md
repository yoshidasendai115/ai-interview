# 12. 面接フロー制御

## 12.1 面接セッション全体フロー

![面接フローシーケンス図](./images/設計書_11.1_面接フロー.png)

## 12.2 HeyGen Streaming Avatar統合

### セッション開始シーケンス

![セッション開始シーケンス](./images/設計書_12.2_セッション開始シーケンス.png)

### HeyGen SDK設定

> **※ JLPTレベル別話速設定の正式定義は [9.3](./09_外部API連携.md#93-heygen-streaming-avatar) を参照**

```typescript
import StreamingAvatar, {
  TaskType,
  AvatarQuality,
  VoiceEmotion
} from "@heygen/streaming-avatar";

const avatar = new StreamingAvatar({
  token: sessionToken
});

// JLPTレベル別話速設定（JLPT_VOICE_RATE）は 09_外部API連携 9.3 を参照

// アバター開始（JLPTレベルに応じた話速設定）
await avatar.createStartAvatar({
  avatarName: "wayne_asian_male",
  language: "ja",
  quality: AvatarQuality.High,
  voice: {
    voiceId: "jp_male_voice",
    rate: JLPT_VOICE_RATE[userJlptLevel],  // 0.5〜1.0
    emotion: VoiceEmotion.FRIENDLY,
  },
});

// 質問発話（セリフ通り）
await avatar.speak({
  text: "自己紹介をお願いします。",
  taskType: TaskType.REPEAT
});
```

> **注意**: `voice.rate`はセッション開始時のみ設定可能。セッション中の動的変更は不可。

## 12.3 JLPTレベル別質問取得（API連携）

### 12.3.1 APIエンドポイント

```
GET /api/v1/questions?jlptLevel=N3
```

> **レスポンス形式**: [10_API仕様 10.5](./10_API仕様.md#105-質問api) を参照

### 12.3.2 質問取得フロー

```
1. InterviewSessionコンポーネントがJLPTレベルをpropsで受け取る
   ↓
2. 面接開始時にfetch('/api/questions?jlptLevel=N3')でAPIを呼び出し
   ↓
3. APIが質問バンク（60問）からカテゴリ別に10問を選択
   ↓
4. JLPTレベルに応じてテキストを選択
   - N1-N3: question_ja（標準）
   - N4-N5: question_simplified（簡易版）
   ↓
5. stateMachine.startInterview(questions)で質問セットを設定
   ↓
6. 各質問のtext（画面表示用）とspokenText（発話用）を使用
```

### 12.3.3 Question型定義

```typescript
interface Question {
  id: string;
  order: number;
  /** 画面表示用テキスト */
  text: string;
  /** HeyGen発話用テキスト（読み仮名） */
  spokenText?: string;
  expectedDurationSeconds: number;
  evaluationCriteria: string[];
}
```

### 12.3.4 カテゴリ別選択数

| カテゴリ | 選択数 |
|----------|--------|
| introduction | 2問 |
| past_experience | 2問 |
| present_ability | 2問 |
| future_vision | 2問 |
| closing | 2問 |
| **合計** | **10問** |

> **注意**: 質問バンクには `conditions`（条件確認）カテゴリ（6問）も存在するが、セッション内の10問選択には含めない。条件確認の質問は面接練習の評価対象外であり、実際の採用面接時に企業側が直接確認する想定のため、練習セッションからは除外している。詳細は [13_面接シナリオ設計 13.3.2](./13_面接シナリオ設計.md#1332-質問カテゴリ構成) を参照。

## 12.4 質問・回答ループ

![質問・回答ループ](./images/設計書_11.3_質問回答ループ.png)

## 12.5 Google Cloud STT統合

### リアルタイム音声認識設定

```typescript
const speechConfig = {
  encoding: "WEBM_OPUS",
  sampleRateHertz: 48000,
  languageCode: "ja-JP",
  enableAutomaticPunctuation: true,
  model: "latest_long",
  useEnhanced: true
};
```

### 音声入力フロー

![音声入力フロー](./images/設計書_12.5_音声入力フロー.png)

## 12.6 セッション完了処理

![セッション完了処理](./images/設計書_12.6_セッション完了処理.png)

### 12.6.1 評価処理の詳細

| 評価種別 | 評価対象 | スコア範囲 | 保存先テーブル |
|---------|---------|----------|--------------|
| 日本語能力評価 | 語彙・文法・内容・敬語 | 0-100点 | evaluation_details |
| 採用適性評価 | 適応力・コミュニケーション力・主体性・定着意向・協調性 | 1-5点 | aptitude_evaluations |
| 統合スコア | 上記2つの加重平均 | 0-100点 | evaluations.total_score |

### 12.6.2 統合スコア計算

統合スコアの計算方法については **07_評価ロジック 7.7.2** を参照。

## 12.7 エラーハンドリング

| エラー種別 | 検出方法 | 対応処理 |
|-----------|---------|---------|
| HeyGen接続失敗 | WebRTC接続エラー | 再接続試行（最大3回）→ テキストモードにフォールバック |
| HeyGen発話エラー | speak() Promise reject | 質問テキストを画面表示で代替 |
| STT接続失敗 | WebSocketエラー | テキスト入力フォームを表示 |
| STT認識失敗 | 空の認識結果 | 再録音を促すメッセージ表示 |
| ネットワーク切断 | navigator.onLine監視 | 再接続待ち画面表示、自動復帰試行 |
| セッションタイムアウト | 60分経過 | セッション中断、途中結果を保存 |

## 12.8 状態管理

```typescript
type SessionState =
  | "initializing"    // HeyGen接続中
  | "ready"           // 接続完了、開始待ち
  | "avatar_speaking" // アバター発話中
  | "listening"       // ユーザー回答待ち
  | "processing"      // 回答処理中
  | "completed"       // セッション完了
  | "error";          // エラー状態

interface SessionContext {
  state: SessionState;
  currentQuestion: number;
  totalQuestions: number;
  answers: Answer[];
  heygenSessionId: string | null;
  sttConnection: WebSocket | null;
}
```

## 12.9 適応型JLPTレベル調整フロー

### 12.9.1 概要

面接評価スコアに基づいて、次回の面接で使用するJLPTレベルを自動調整する。
詳細な調整ルールは **07_評価ロジック 7.10** を参照。

![レベル調整フロー](./images/設計書_12.9_レベル調整フロー.png)

### 12.9.2 練習モード選択

ホーム画面から面接練習を開始する際、ユーザーは以下のモードを選択できる。

#### 練習モード一覧

| モード | 説明 | 対象 |
|--------|------|------|
| 学習計画モード | 学習計画に沿った練習 | 学習計画が存在するユーザー |
| 自由練習モード | 任意のレベル・業界で練習 | 全ユーザー |

#### モード選択画面のUI仕様

| 要素 | 表示条件 | 内容 |
|-----|---------|------|
| 学習計画カード | 学習計画あり | 「学習計画を続ける」+ 進捗表示 |
| 自由練習カード | 常時 | 「自由に練習する」 |
| おすすめバッジ | 学習計画あり | 学習計画カードに表示 |

#### モード選択フロー

```
1. ホーム画面で「面接練習を始める」をタップ
   ↓
2. モード選択画面を表示
   ├─ 学習計画あり → 「学習計画を続ける」（推奨）＋「自由に練習する」
   └─ 学習計画なし → 「自由に練習する」のみ表示
   ↓
3. ユーザーがモードを選択
   ├─ 学習計画モード → 現在のステップに基づいてセッション開始
   └─ 自由練習モード → レベル・業界選択画面へ
```

#### モード別のセッション保存

| モード | interview_sessions保存内容 |
|--------|----------------------|
| 学習計画モード | `learning_step_id = 現在のステップID`, `is_free_practice = false` |
| 自由練習モード | `learning_step_id = NULL`, `is_free_practice = true` |

### 12.9.3 チャレンジ枠フロー

```
1. ホーム画面で「面接練習を始める」をタップ
   ↓
2. チャレンジ選択画面を表示
   - 申告レベル表示（例: N3）
   - 通常練習ボタン（推奨）
   - チャレンジボタン（1つ上のレベル）
   ↓
3. ユーザーが選択
   - 通常練習 → 申告レベルで面接開始
   - チャレンジ → 上位レベルで面接開始（is_challenge = true）
   ※ N1ユーザーはチャレンジボタン非表示
   ↓
4. アバター接続・面接実施
   ↓
5. セッション完了時にDB保存
   - interview_sessions.jlpt_level: 実際に使用したレベル
   - interview_sessions.is_challenge: チャレンジモードかどうか
   ↓
6. チャレンジモードの場合、LocalStorageでチャレンジ回数を更新
```

#### チャレンジ選択画面のUI仕様

| 要素 | 表示条件 | 内容 |
|-----|---------|------|
| 申告レベル表示 | 常時 | 「あなたのレベル: N○」 |
| 通常練習ボタン | 常時 | 「通常練習（N○）」+ 推奨バッジ |
| チャレンジボタン | N1以外 | 「1つ上のレベルに挑戦！」 |

#### JLPTレベルの取得

JLPTレベルはmintoku workからSSO認証時に必ず連携される必須項目である。チャレンジ選択画面では、連携されたJLPTレベルを基に通常練習・チャレンジの選択肢を表示する。

#### セッション開始時の業界ID決定ルール

| モード | industry_id取得元 |
|--------|------------------|
| 学習計画モード | `learning_plans.industry_id`（現在のステップのプランから） |
| 自由練習モード | `user_preferred_industries.industry_id`（ユーザー希望業界から） |
| 業界未設定時 | `NULL`（汎用質問セットを使用） |

#### データ保存フロー

```
セッション開始時:
  └─ interview_sessions INSERT
     ├─ jlpt_level: 選択したレベル（通常/チャレンジ）
     ├─ is_challenge: チャレンジモードか
     ├─ industry_id: 上記ルールに従って決定
     ├─ learning_step_id: 学習計画モード時のみ設定
     └─ is_free_practice: 自由練習モード時はtrue

セッション完了時:
  ├─ interview_sessions UPDATE (status, completed_at, duration_seconds)
  ├─ evaluations INSERT
  ├─ evaluation_details INSERT（日本語能力評価）
  ├─ aptitude_evaluations INSERT（採用適性評価）
  └─ LocalStorage更新（チャレンジ回数、最終練習日時）
```

### 12.9.4 チャレンジ回数のリセット

- 1日（00:00 JST）ごとにリセット
- LocalStorageのtimestampで判定

### 12.9.5 フィードバック画面の表示パターン

| パターン | スコア | 現在レベル | 表示内容 |
|---------|--------|-----------|---------|
| A | 70点以上 | N5〜N2 | 「素晴らしい！N○にチャレンジしましょう！」+ レベルアップボタン |
| B | 70点以上 | N1 | 「最高レベル（N1）で優秀な成績です！」+ 継続ボタン |
| C | 31〜69点 | N5〜N1 | 「もう少し練習しましょう。」+ 再挑戦ボタン + 上位チャレンジボタン |
| D | 30点以下 | N4〜N1 | 「基礎から練習しましょう。」+ レベルダウンボタン |
| E | 30点以下 | N5 | 「N5で基礎を固めましょう。」+ 継続ボタン |

### 12.9.6 平均スコア表示

複数回受験時のフィードバック画面に以下を表示：

```
┌─────────────────────────────────┐
│ 最終評価（平均） - N3           │
│ ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━ │
│ 75点                           │
│ 受験回数: 3回                   │
│ 最高: 82点  最低: 68点          │
└─────────────────────────────────┘
```

### 12.9.7 長期離脱ユーザーのウォームアップ

#### 判定条件

| 項目 | 閾値 |
|------|------|
| 離脱期間 | 最終セッションから14日以上 |
| 対象 | 学習計画が進行中のユーザー |

#### ウォームアップフロー

```
1. ログイン時に最終セッション日時を確認
   ↓
2. 14日以上経過している場合
   ↓
3. ウォームアップ提案ダイアログを表示
   - 「お久しぶりです！まずは軽い練習から始めませんか？」
   - オプション1: 「ウォームアップ練習」→ 1つ下のレベルで短縮版（5問）
   - オプション2: 「通常練習を再開」→ 現在のステップを継続
   ↓
4. ウォームアップ選択時
   - is_warmup = true でセッション作成
   - 学習計画の進捗にはカウントしない
```

#### ウォームアップダイアログのUI仕様

| 要素 | 内容 |
|------|------|
| タイトル | 「お久しぶりです！」 |
| 説明 | 「前回の練習から{N}日経過しています。軽いウォームアップから始めませんか？」 |
| オプション1 | 「ウォームアップ練習」（1つ下のレベル、5問、進捗カウント外） |
| オプション2 | 「通常練習を再開」（現在のステップをそのまま継続） |

#### ウォームアップセッションの特徴

| 項目 | 内容 |
|------|------|
| JLPTレベル | 現在のステップより1つ下（N5の場合はN5のまま） |
| 質問数 | 5問（通常の半分） |
| 進捗カウント | なし（`learning_steps.completed_sessions`は更新しない） |
| 日次練習時間 | カウントする（ユーザーの練習習慣として記録） |
| 週次統計 | カウントする（セッション実施数・練習時間に含める） |
| 評価 | 通常通り実施（フィードバックあり） |
| DBフラグ | `interview_sessions.is_warmup = true` |

### 12.9.8 LocalStorageデータの復旧

LocalStorageがクリアされた場合（ブラウザのデータ削除、別端末からのアクセス等）の対応。

#### 復旧が必要なシナリオ

| シナリオ | 発生条件 | 影響 |
|---------|---------|------|
| ブラウザデータ削除 | ユーザーがキャッシュクリア | チャレンジ回数リセット |
| 別端末アクセス | PCからスマホに切り替え | 当日のチャレンジ状態が同期されない |
| シークレットモード | プライベートブラウジング | 毎回初期状態 |

#### 復旧フロー

```
1. 面接練習画面アクセス時
   ↓
2. LocalStorageにchallengeStateが存在するか確認
   ├─ 存在する → 通常フローへ
   └─ 存在しない → 復旧フローへ
   ↓
3. GET /api/v1/users/me でユーザー情報取得
   - jlpt_level を取得
   ↓
4. GET /api/v1/sessions?date=today&is_challenge=true で当日のチャレンジ履歴取得
   - 当日のチャレンジセッション数をカウント
   ↓
5. challengeState を再構築
   - declaredLevel: users.jlpt_level
   - challengeCount: 当日のチャレンジセッション数
   - lastResetDate: 当日日付
   ↓
6. LocalStorageに保存
   ↓
7. チャレンジ選択画面へ遷移
```

#### 復旧時のデータ構造

```typescript
interface ChallengeState {
  declaredLevel: 'N1' | 'N2' | 'N3' | 'N4' | 'N5';
  challengeCount: number;  // 0-3
  lastResetDate: string;   // YYYY-MM-DD形式
}

// 復旧処理
async function recoverChallengeState(): Promise<ChallengeState> {
  const user = await fetch('/api/v1/users/me').then(r => r.json());
  const today = new Date().toISOString().split('T')[0];
  const sessions = await fetch(`/api/v1/sessions?date=${today}&is_challenge=true`)
    .then(r => r.json());

  return {
    declaredLevel: user.jlpt_level,
    challengeCount: sessions.length,
    lastResetDate: today
  };
}
```

#### 復旧できない場合の振る舞い

| 状況 | 対応 |
|------|------|
| API接続失敗 | ローディング表示後、リトライ（最大3回） |
| 3回リトライ失敗 | エラーメッセージ表示、ホームへ戻るボタン |

#### セッション履歴の同期

LocalStorageに保存するセッション履歴（平均スコア計算用）は、DB側のデータを正として同期する。

```
セッション履歴の取得:
GET /api/v1/sessions?limit=30&include_evaluations=true

レスポンス:
{
  "sessions": [
    {
      "session_id": "ses_123",
      "jlpt_level": "N3",
      "is_challenge": false,
      "total_score": 75,
      "completed_at": "2025-02-04T10:30:00Z"
    }
  ]
}
```

## 12.10 業界別学習計画機能

### 12.10.1 概要

ユーザーの希望業界に基づいて学習計画（カリキュラム）を自動生成し、計画的な面接練習を促進する。
希望業界情報は mintoku work から連携される。

### 12.10.2 mintoku work からの業界連携フロー

```
1. ユーザーが mintoku work でプロフィール設定
   - 希望業界を1つ登録
   ↓
2. ユーザーが本システムにSSO認証でログイン
   ↓
3. POST /api/v1/auth/callback で認証処理
   ↓
4. mintoku work API から希望業界情報を取得
   GET https://api.mintoku-work.com/v1/users/{user_id}/preferences
   ↓
5. users テーブル更新
   - industry_synced_at = NOW()
   ↓
6. user_preferred_industries テーブル同期
   - 既存データを DELETE
   - 新規連携データを INSERT（1件のみ）
   - 例: (user_id, 'construction')
   ↓
7. 学習計画存在判定（下記 12.10.3 参照）
   - 既存の active プランを検索
   - 判定結果に応じて処理を分岐
```

#### mintoku work API レスポンス例

```json
{
  "user_id": "mintoku-user-123",
  "preferred_industry": {
    "industry_id": "construction",
    "industry_name": "建設業"
  }
}
```

#### 希望業界なしの場合

```json
{
  "user_id": "mintoku-user-456",
  "preferred_industry": null
}
```

### 12.10.3 学習計画存在判定ロジック

認証コールバック処理内で、学習計画の存在と業界変更を判定する。
この処理は**同期的**に実行され、ホーム画面遷移前に完了する。

#### 判定フロー

![学習計画存在判定ロジック](./images/設計書_12.10.3_学習計画存在判定.png)

#### データソース

| テーブル | 用途 | 検索条件 |
|---------|------|---------|
| `learning_plans` | 既存プランの存在確認 | `user_id = ? AND status = 'active'` |
| `user_preferred_industries` | 現在の希望業界取得 | `user_id = ?` |

#### 判定結果と処理

| 既存プラン | 業界変更 | 処理 |
|-----------|---------|------|
| なし | - | 新規作成（12.10.4 へ） |
| あり | なし | 何もしない（既存プラン継続） |
| あり | あり | 既存を archived → 新規作成（12.10.4 へ） |

#### 判定コード例

```typescript
async function checkAndCreateLearningPlan(
  userId: string,
  newIndustryId: string | null
): Promise<void> {
  // 1. 既存のactiveプランを検索
  const existingPlan = await db.learningPlans.findFirst({
    where: { userId, status: 'active' }
  });

  if (!existingPlan) {
    // 2a. プランなし → 新規作成
    await generateLearningPlan(userId, newIndustryId);
    return;
  }

  // 2b. プランあり → 業界変更チェック
  const industryChanged = existingPlan.industryId !== newIndustryId;

  if (!industryChanged) {
    // 3a. 業界変更なし → 何もしない
    return;
  }

  // 3b. 業界変更あり → 既存をarchived、新規作成
  await db.learningPlans.update({
    where: { id: existingPlan.id },
    data: { status: 'archived', updatedAt: new Date() }
  });

  await generateLearningPlan(userId, newIndustryId);
}
```

---

### 12.10.4 学習計画生成ロジック

#### データソース

> **※ 学習計画テンプレートの正式データは `backend/app/data/seed/learning_step_templates.json` を参照**

#### 生成条件

| 条件 | 生成される学習計画 |
|------|------------------|
| 希望業界あり | 希望業界に特化した学習計画を生成 |
| 希望業界なし | 汎用学習計画を生成 |

#### 学習計画テンプレート（業界あり）

例: 建設業界の場合

| ステップ | step_type | jlpt_level | required_sessions | 説明 |
|---------|-----------|------------|-------------------|------|
| 1 | introduction | N5 | 1 | 基本的な自己紹介練習 |
| 2 | practice | N5 | 2 | N5レベルで建設業界質問に慣れる |
| 3 | practice | N4 | 3 | N4レベルで実践練習 |
| 4 | challenge | N3 | 1 | チャレンジモードで上位レベル挑戦 |
| 5 | practice | N3 | 3 | N3レベルで深掘り練習 |
| 6 | challenge | N2 | 1 | 上位挑戦 |

#### 学習計画テンプレート（汎用・業界なし）

| ステップ | step_type | jlpt_level | required_sessions | 説明 |
|---------|-----------|------------|-------------------|------|
| 1 | introduction | N5 | 1 | 基本面接練習 |
| 2 | practice | N5 | 2 | N5レベル汎用質問 |
| 3 | practice | N4 | 3 | N4レベル汎用質問 |
| 4 | practice | N3 | 3 | N3レベル汎用質問 |

#### 学習計画生成コード例

```typescript
interface LearningPlanTemplate {
  steps: {
    stepNumber: number;
    stepType: 'introduction' | 'practice' | 'challenge';
    jlptLevel: 'N1' | 'N2' | 'N3' | 'N4' | 'N5';
    requiredSessions: number;
  }[];
}

// 業界別テンプレート取得
function getLearningPlanTemplate(industryId: string | null): LearningPlanTemplate {
  if (industryId) {
    // 業界固有テンプレート
    return INDUSTRY_TEMPLATES[industryId] || DEFAULT_INDUSTRY_TEMPLATE;
  }
  // 汎用テンプレート
  return GENERIC_TEMPLATE;
}

// 学習計画生成
async function generateLearningPlan(
  userId: string,
  industryId: string | null,
  scenarioTemplateId: string
): Promise<void> {
  const template = getLearningPlanTemplate(industryId);

  // 学習計画作成
  const plan = await db.learningPlans.create({
    userId,
    industryId,
    scenarioTemplateId,
    status: 'active',
  });

  // ステップ作成
  for (const step of template.steps) {
    await db.learningSteps.create({
      learningPlanId: plan.id,
      stepNumber: step.stepNumber,
      stepType: step.stepType,
      jlptLevel: step.jlptLevel,
      requiredSessions: step.requiredSessions,
      completedSessions: 0,
      status: step.stepNumber === 1 ? 'in_progress' : 'pending',
      unlockedAt: step.stepNumber === 1 ? new Date() : null,
    });
  }
}
```

### 12.10.5 セッション完了時の進捗更新ロジック

```
1. 面接セッション完了
   PUT /api/v1/sessions/{id}/complete
   ↓
2. interview_sessions.status = 'completed' に更新
   ↓
3. 評価処理実行（非同期）
   ↓
4. ユーザーのアクティブ学習計画を取得
   SELECT * FROM learning_plans WHERE user_id = ? AND status = 'active'
   ↓
5. 現在のステップを取得
   SELECT * FROM learning_steps
   WHERE learning_plan_id = ? AND status = 'in_progress'
   ↓
6. completed_sessions をインクリメント
   UPDATE learning_steps SET completed_sessions = completed_sessions + 1
   ↓
7. 必要セッション数に達したか判定
   IF completed_sessions >= required_sessions THEN
     - learning_steps.status = 'completed'
     - learning_steps.completed_at = NOW()
     - 次のステップを 'in_progress' に更新
     - 次のステップの unlocked_at = NOW()
   ↓
8. 全ステップ完了の場合
   - learning_plans.status = 'completed'
   - 次のコースを提案（オプション）
```

#### 進捗更新コード例

```typescript
async function updateLearningProgress(
  userId: string,
  sessionId: string
): Promise<void> {
  // アクティブ学習計画を取得
  const plan = await db.learningPlans.findOne({
    where: { userId, status: 'active' }
  });

  if (!plan) return;

  // 現在進行中のステップを取得
  const currentStep = await db.learningSteps.findOne({
    where: { learningPlanId: plan.id, status: 'in_progress' }
  });

  if (!currentStep) return;

  // 完了セッション数をインクリメント
  currentStep.completedSessions += 1;

  // 必要セッション数に達したか判定
  if (currentStep.completedSessions >= currentStep.requiredSessions) {
    // ステップ完了
    currentStep.status = 'completed';
    currentStep.completedAt = new Date();
    await currentStep.save();

    // 次のステップを解放
    const nextStep = await db.learningSteps.findOne({
      where: {
        learningPlanId: plan.id,
        stepNumber: currentStep.stepNumber + 1
      }
    });

    if (nextStep) {
      nextStep.status = 'in_progress';
      nextStep.unlockedAt = new Date();
      await nextStep.save();
    } else {
      // 全ステップ完了
      plan.status = 'completed';
      await plan.save();
    }
  } else {
    await currentStep.save();
  }
}
```

#### 学習計画完了後のユーザーフロー

全ステップ完了時（`learning_plans.status = 'completed'`）のユーザー体験:

```
1. 最終セッション完了 → 評価結果表示
   ↓
2. 「学習計画を達成しました！」完了バッジ表示
   ↓
3. ホーム画面の学習計画エリア更新
   - 完了バッジ + 「おめでとうございます！」メッセージ
   - 次のコース提案（例: N3完了 → N2コースへの挑戦を提案）
   ↓
4. ユーザー選択
   - 「新しいコースを始める」→ 上位レベルの学習計画を自動生成
   - 「自由に練習する」→ フリーモードで継続
```

> **画面表示仕様**: 完了バッジ・次のコース提案の表示仕様は [06_画面設計](./06_画面設計.md) を参照。

### 12.10.6 チャレンジステップの評価ルール

チャレンジモード（`step_type = 'challenge'`）での評価特則を定義する。

#### 基本方針

| 項目 | 内容 |
|------|------|
| 合格閾値 | なし（チャレンジは常に「完了」扱い） |
| 失敗扱い | なし（低スコアでもステップ完了） |
| 目的 | 上位レベルへの挑戦経験を積む |

チャレンジステップは「合格/不合格」ではなく、上位レベルに挑戦する経験を通じて学習者のモチベーションを維持することが目的である。

#### 評価結果による学習アドバイス

| スコア範囲 | フィードバックメッセージ | 次のアクション |
|-----------|----------------------|--------------|
| 70点以上 | 「上位レベルへの準備ができています！」 | 次のステップへ進む |
| 50-69点 | 「良いチャレンジでした。継続練習を推奨します」 | 次のステップへ進む |
| 50点未満 | 「現在のレベルでの練習を続けてから再挑戦しましょう」 | 次のステップへ進む（補足アドバイス表示） |

> **注意**: どのスコアでもチャレンジステップは「完了」となり、次のステップに進む。
> スコアに応じてフィードバックメッセージの内容を変えることで、学習者に適切なアドバイスを提供する。

#### チャレンジステップ完了時の処理

```
1. セッション完了
   ↓
2. 評価処理実行
   ↓
3. learning_steps.status = 'completed'（スコアに関係なく）
   ↓
4. 次のステップを 'in_progress' に更新
   ↓
5. フィードバック画面にスコアに応じたメッセージを表示
```

### 12.10.7 学習計画取得API

```
GET /api/v1/users/me/learning-plan

Response:
{
  "plan_id": "uuid",
  "industry_id": "construction",
  "industry_name": "建設",
  "status": "active",
  "progress": {
    "completed_steps": 2,
    "total_steps": 6,
    "percentage": 33
  },
  "current_step": {
    "step_number": 3,
    "step_type": "practice",
    "jlpt_level": "N4",
    "required_sessions": 3,
    "completed_sessions": 1,
    "remaining_sessions": 2
  },
  "steps": [
    {
      "step_number": 1,
      "step_type": "introduction",
      "jlpt_level": "N5",
      "status": "completed"
    },
    {
      "step_number": 2,
      "step_type": "practice",
      "jlpt_level": "N5",
      "status": "completed"
    },
    {
      "step_number": 3,
      "step_type": "practice",
      "jlpt_level": "N4",
      "status": "in_progress"
    }
  ]
}
```

### 12.10.8 業界変更時の学習計画更新

mintoku work で希望業界が更新された場合の対応。

#### 業界変更確認ダイアログ

業界変更が検出された場合、以下の確認ダイアログを表示する。

| 要素 | 内容 |
|------|------|
| タイトル | 「希望業界が変更されました」 |
| 説明 | 「〇〇業界から△△業界に変更されました。新しい業界の学習計画を作成しますか？」 |
| オプション1 | 「新しい計画を開始」→ 既存プランarchived、新規作成 |
| オプション2 | 「今の計画を続ける」→ 変更せず継続 |

#### 業界変更処理フロー

```
1. ユーザーがログイン（業界情報再同期）
   ↓
2. 希望業界の変更を検出
   - 旧: construction
   - 新: food_service
   ↓
3. 業界変更確認ダイアログを表示
   ├─ 「新しい計画を開始」を選択
   │   ↓
   │   4a. 既存のアクティブプランをアーカイブ
   │       UPDATE learning_plans SET status = 'archived'
   │       WHERE user_id = ? AND status = 'active'
   │   ↓
   │   5a. 新しい業界の学習計画を生成
   │       - industry_id: 'food_service'
   │       - status: 'active'
   │   ↓
   │   6a. 新しいステップを生成
   │
   └─ 「今の計画を続ける」を選択
       ↓
       4b. 何もしない（既存プラン継続）
       ↓
       5b. user_preferred_industriesは更新（次回のプラン作成時に使用）
```

#### 進捗データの保持

| データ | 業界変更後の扱い |
|--------|----------------|
| 旧学習計画 | `status='archived'`で保持（履歴参照可能） |
| 過去セッション | 変更なし（履歴として保持） |
| 苦手項目 | 変更なし（引き継ぎ） |
| 累計練習回数 | 変更なし（引き継ぎ） |

> **注意**: 業界変更で旧プランをarchivedにしても、過去の練習履歴やセッションデータは削除されない。
> ユーザーは学習進捗画面から過去の練習履歴を参照できる。

### 12.10.9 非ログイン中の業界変更通知処理

ユーザーが非ログイン状態でmintoku workから業界変更Webhookを受信した場合の処理。

#### Webhook受信時の処理分岐

```
Webhook受信時の処理:
├─ ユーザーがログイン中
│   → 即時適用（既存フロー: 12.10.8参照）
│
└─ ユーザーが非ログイン
    → users.pending_industry_id に保存
    → users.pending_industry_notified_at = NOW()
    → 次回ログイン時に適用
```

#### ログイン時のpending_industry_id処理

```
ログイン処理:
1. users.pending_industry_id を確認
   ├─ NULLの場合 → 通常のログイン処理へ
   └─ 値がある場合 → ステップ2へ
   ↓
2. 業界変更確認ダイアログを表示（12.10.8参照）
   ↓
3. ユーザーの選択に応じて処理
   ├─ 「新しい計画を開始」→ 学習計画再生成
   └─ 「今の計画を続ける」→ 継続
   ↓
4. pending_industry_id = NULL にクリア
   pending_industry_notified_at = NULL にクリア
   ↓
5. 通常のログイン処理へ
```

#### データベース更新フロー

```sql
-- Webhook受信時（非ログイン）
UPDATE users
SET pending_industry_id = 'new_industry_id',
    pending_industry_notified_at = NOW()
WHERE mintoku_user_id = 'user_id';

-- ログイン時（処理後）
UPDATE users
SET pending_industry_id = NULL,
    pending_industry_notified_at = NULL
WHERE id = 'user_uuid';
```

### 12.10.10 エラーハンドリング

| エラー種別 | 検出方法 | 対応処理 |
|-----------|---------|---------|
| mintoku work API 接続失敗 | タイムアウト/HTTPエラー | リトライ（最大3回）、失敗時は既存データで続行 |
| 業界情報取得失敗 | APIレスポンスエラー | 汎用プランを生成 |
| 学習計画生成失敗 | DB書き込みエラー | エラーログ + ユーザーに通知 |
| 進捗更新失敗 | DB更新エラー | セッション評価は正常完了、進捗更新を非同期リトライ |
